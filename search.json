[{"categories":null,"content":"about me","date":"2025-08-25","objectID":"/about/","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"社会稳定一份子 退耕还林倡导者 控制科学自由人 电子制作门外汉 智能小车梦想家 三昧真火炼丹师 C++受虐狂 Linux键盘侠 EarthOnline差等生 ","date":"2025-08-25","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["操作系统"],"content":"本文是作者自己总结的《Operating Systems:Three Easy Pieces》读书笔记","date":"2025-08-23","objectID":"/posts/ostep-note/","tags":["操作系统导论","读书笔记"],"title":"操作系统导论读书笔记","uri":"/posts/ostep-note/"},{"categories":["操作系统"],"content":"《Operating Systems:Three Easy Pieces》是Arpaci-Dusseau教授夫妇所著，向Richard Feynman的《费曼物理学讲义》致敬。本书围绕虚拟化、并发和持久化三个主题展开。“教育过程的真正意义在于：前进，学习许多新的和引人入胜的主题，通过学习不断成熟，最重要的是，找到能为你点火的东西。” 操作系统介绍 冯诺依曼计算模型的基本概念，运行的程序会做一件非常简单的事情：执行指令（CPU是一个无情执行指令的机器，程序是状态机）。处理器不断取指（内存中）、译码、执行、写回。操作系统是一类软件，负责让程序运行变得容易。 操作系统主要利用虚拟化技术将物理资源转换为虚拟形式，虚拟化CPU将单个CPU转换为看似无限数量的CPU，从而让许多程序看似同时运行；虚拟化内存，每个进程访问自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上，物理内存是操作系统管理的共享资源。 并发问题在同时（并发地）处理很多事情时出现且必须解决。多线程程序对共享计数器必须进行处理，对于这种增加计数值时需要三条指令：1. 将计数器的值从内存加载到寄存器；2. 递增值；3. 将寄存器的值保存回内存。这三条指令不是原子执行（所有指令一次性执行）的，所以会有怪事发生。 断电或系统崩溃，内存中的数据就会丢失，需要硬件（磁盘）和软件（文件系统）持久地存储数据。操作系统不会虚拟化磁盘而是假设用户经常需要共享文件中的信息。文件系统部分的系统调用有open()、write()、close()等，首先确定新数据放到磁盘哪个位置，然后在文件系统所维护的各种结构中进行记录，需要向底层存储设备发出I/O请求。出于性能方面考虑，首先延迟写操作一段时间，将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，文件系统包含某种复杂的写入协议，如日志或写时复制，仔细排序写入磁盘的操作，以确保恢复到合理的状态。 设计一个操作系统的目标：1. 建立一些抽象；2. 提供高性能；3. 在OS和应用程序之间提供隔离；4. 可靠。 虚拟化 进程 进程：运行中的程序，OS为运行的程序所提供的抽象。进程的机器状态：内存和寄存器。所有OS需要提供的API：创建、销毁、等待、其他控制、状态。OS运行程序必须做的第一件事：将磁盘中的代码和所有静态数据加载到内存中，加载到进程的地址空间中。OS在加载时也是惰性加载，仅在程序执行期间需要加载的代码和数据才会加载。第二件事，为程序运行时栈分配内存空间，也可能分配堆空间。还会执行一些其他初始化任务，特别是I/O相关。默认每个进程有三个文件描述符fd，标准输入、输出和错误。 进程状态：运行、就绪、阻塞。运行和就绪可以相互转换，通过CPU调度和取消调度。阻塞（被某种事件阻塞）需要等待某种事件发生。初始：进程刚创建；最终：已退出但尚未清理（僵尸状态）。这里僵尸进程是指子进程先于父进程退出后，父进程没有释放子进程的PCB，如果父进程不结束，那么一直保持僵尸进程状态，占用系统资源，如果父进程结束了，init进程会自动接手子进程并收尸。与之相对的是孤儿进程，孤儿进程是父进程先于子进程退出，那么会被init进程收养，不会占用系统资源。僵尸进程的处理办法：1. 杀死父进程，大多数情况不可取。2. SIGCHLD信号处理，实际上当子进程终止时，内核会向它的父进程发送一个SIGCHLD信号，父进程可以选择忽略（默认）还是提供处理函数（调用wait或waitpid函数释放子进程占用的资源）。 fork()：这个系统调用确实比较奇怪，初学时很难接受是怎么做到同一个程序同时运行相同的代码的。fork的话会创建一个子进程，子进程copy了父进程（内存和寄存器值），但是返回值不同（子进程返回值为0）。fork的子进程不会执行fork之前的代码。 wait()：父进程可以延迟执行，调用wait等待子进程执行完毕再执行，这个系统调用也会回收子进程的资源。 exec()：可以让子进程执行与父进程不同的程序，exec会从可执行程序中加载代码和静态数据，并覆盖自己的代码段和静态数据，堆、栈及其他内存空间也会被重新初始化，然后OS就会执行该程序，将参数通过argv传给该进程。这里说明exec是完全转头调用所指定的可执行程序。这种分离fork和exec的做法在构建shell时非常有用，因为这给了shell在fork之后exec之前运行代码的机会。比如shell作为主进程在fork了一个子进程后通过exec执行wc系统调用统计文件字符数，可以使用重定向将输出从标准输出改为某个文件，而这实现原理就是在fork之后exec之前关闭标准输出的文件描述符，打开文件，新打开的文件将成为第一个可用的文件描述符，从而向文件中写入。 受限直接执行 时分共享CPU实现虚拟化：看起来同时运行多个进程。在保持控制权的同时获得高性能是构建操作系统的主要挑战之一。 用户态和内核态切换：划分用户空间和内核空间区分受限操作执行，内核空间可以做everything，执行受限的指令；用户空间需要执行这些受限的指令就需要执行系统调用，而要执行系统调用就必须执行trap指令，该指令同时跳转入内核，从而执行特权指令，完成后，OS调用一个trap返回指令返回到用户空间。这涉及到内核态到用户态的转换，在trap时处理器需要将一些寄存器保存到每个进程的内核栈上，trap返回时从栈中弹出这些值。open()系统调用和C的过程调用看起来差不多，是的，open()是一个过程调用但内部有trap指令，在执行open()时会用汇编处理参数和返回值以及执行trap指令。然而需要考虑的一点是，trap进内核的代码地址不能是任意的（出于安全考虑），那么每个系统调用或中断在trap进内核后都会被指定对应的处理程序地址，这个对应关系保存在trap表中。 进程间切换：OS作为一个进程（类似的）也要运行在CPU上，如果子进程去执行一个死循环而不主动让出CPU的控制权那么OS就失去了CPU的控制权，唯一办法是重启大法。这显然不合理，需要其他办法获得CPU的控制权。时钟中断，和系统调用一样，必须有对应的中断处理函数，以及在系统开始时也必须启动时钟。 上下文切换：系统开启时钟中断，中断产生后，发生进程切换，也就有进程间的上下文切换。上下文切换就是保存当前执行进程的寄存器的值，恢复即将执行进程的寄存器的值。为了保存当前进程的上下文，OS会执行一些汇编代码来保存通用寄存器、程序计数器、内核栈指针，然后恢复通用寄存器、程序计数器、切换内核栈，以供即将执行进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程的上下文，返回时，是另一个进程的上下文。当OS最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程，至此上下文切换完成。 这里可以这样理解，进程进行上下文切换，那么什么是上下文？上下文肯定是描述进程的东西，那么进程由什么来描述？就是PCB，简单来说主要包括寄存器和内存，每个进程有自己运行时寄存器的值，每个进程有自己看起来独有的内存空间（包括栈和堆）。那么上下文就包括这些，切换的也就是寄存器的值、内存空间。具体过程就是保存正在执行的进程A的寄存器（通用寄存器、程序计数器、栈指针等）到内核空间的一块内存中（cpu_context结构体保存），把即将要执行的进程B所保存的上下文内存块中（cpu_context）的值恢复到寄存器中，这是硬件上下文的切换；也别忘了还有内存空间的切换，具体就是切换进程B的pgd（页全局目录的虚拟地址）所对应的页全局目录的物理地址到页表基址寄存器中，当访问用户空间时MMU会通过页表基址寄存器来遍历页表得到物理地址。 而下边表中保存和恢复了两次寄存器，容易误导。实际上下文切换的就是调用switch()例程的一次寄存器的保存和恢复，而另一次是中断所伴随的，即不论是否是上下文切换的场景，只要中断产生都会将用户态的寄存器的值保存到内核栈，然后恢复，这里称为保存现场，不要与进程上下文搞混。 受限直接执行协议（时钟中断） 所谓的受限直接执行的含义是：OS在启动时设置陷阱处理程序并启动时钟中断，然后仅在受限模式下运行进程，以此为CPU提供宝宝防护。这是虚拟化CPU的基本机制。 进程调度 调度指标：周转时间，周转时间=完成时间-到达时间，这是一个性能指标。另一个有趣的目标是公平，两者往往是矛盾的。 先进先出 FIFO 最短任务优先 SJF 同时到达的任务先运行短时间的 最短完成时间优先 STCF 向SJF添加抢占则为最短完成时间优先，随时到达随时评估 新的调度指标：响应时间，响应时间=首次运行时间-到达时间。其实就对应了任务的响应优先级，考虑到了某些运行时间长的任务一直得不到响应的情况。 轮转 RR 时间片轮转，划分固定的时间片给每个任务，按任务队列顺序依次占有CPU 时间片时间越短响应时间越好，但是需要摊销上下文切换成本，让上下文切换时间占比不要太高 上下文切换的成本不仅来自上述所说的操作，在CPU cache、TLB等硬件上建立了大量的状态，这些切换也可能导致显著的性能成本。 这样会导致周转时间指标很差，因为作为一个公平的策略 结合I/O 这里主要是指实际场景中可以利用I/O操作耗时的间隙进行CPU操作从而更好利用CPU 多级反馈队列 MLFQ Corbato提出，获得图灵奖 需要联合考虑周转时间和响应时间两个指标 是用历史经验预测未来的一个经典例子，以史为鉴，更多的是基于行为制定规则，而不是先验知识 划分不同优先级的不同队列，每个队列之间用RR，I/O密集型的优先级高（占用CPU时间短），CPU密集型的优先级低（占用CPU时间长），优先级大的先运行，","date":"2025-08-23","objectID":"/posts/ostep-note/:0:0","tags":["操作系统导论","读书笔记"],"title":"操作系统导论读书笔记","uri":"/posts/ostep-note/"},{"categories":["测试分类"],"content":"这是一个用于测试的文章，帮助验证Hugo-FixIt配置的正确性。","date":"2025-01-25","objectID":"/posts/article-test/","tags":["测试","Hugo","FixIt"],"title":"文章测试","uri":"/posts/article-test/"},{"categories":["测试分类"],"content":"标题 h3 标题 h4 标题 h5 标题 h6 标题 段落 这是第一段话。 这是第二段话。 换行 这是第一行。 这是第二行。 强调 这是粗体。 这是斜体。 这是既粗又斜体。 块引用 块引用前有空白行！ 这是块引用。 这是嵌套块引用。 块引用后有空白行！ 列表 第一 第二 第三 无序一 无序二 在此项里要空一个Tab。 无序三 代码块 #include \u003ciostream\u003e\rint main(){\rstd::cout \u003c\u003c \"这是缩进方式的代码块\";\r}\r#include \u003ciostream\u003e int main(){ std::cout\u003c\u003c \"这是围栏方式的代码块\"; } 图片 代码 这里是Hugo生成的静态网站。 分割线 我在分割线之上。 我在分割线之下。 链接 这篇文章参考了Markdown Guide。 这篇文章参考了Markdown Guide（引用式链接）。 表格 语法 描述 示例 标题 # # h1 强调 ** 这是强调 脚注 这是一个简单的脚注，1还有个更复杂的脚注。2 定义 Markdown 一种轻量级标记语言。 删除线 Markdown我不会现在我会了 任务列表 选中 未选中 Emoji 输入法打出来的😂 表情符号的短代码 :tent: 高亮 这是高亮。 上下标 下标：H2O 上标：x2 警示 注意 突出显示用户应考虑的信息，即使只是浏览也应考虑。 提示 可选信息，可帮助用户取得更大的成功。 重要 用户成功所需的关键信息。 警告 由于存在潜在风险，需要用户立即关注的关键内容。 小心 操作的潜在负面后果。 FixIt 一个简洁、优雅且高效的 Hugo 主题。 任务列表 未完成 已完成 进行中 已取消 已计划 已重新计划 重要 问题 下划线 这是下划线。 数学公式 这是行内公式：$c = \\pm\\sqrt{a^2 + b^2}$ 这是公式块： $$ c = \\pm\\sqrt{a^2 + b^2} $$ 字符注音 Markdown一种轻量级标记语言 分数 99/100 简单的脚注 ↩︎ 复杂的脚注 ↩︎ ","date":"2025-01-25","objectID":"/posts/article-test/:0:0","tags":["测试","Hugo","FixIt"],"title":"文章测试","uri":"/posts/article-test/"}]