# 程序员的自我修养读书笔记


《程序员的自我修养——链接、装载与库》

<!--more--> 

## 简介
对于系统程序开发者来说，计算机硬件设备中有三个部件最为关键，分别是中央处理器CPU、内存和I/O控制芯片。连接所有高速芯片的是北桥，专门处理低速设备的是南桥，北桥连接着PCI总线，南桥连接着ISA总线。南桥挂在PCI总线上，从而与北桥交换数据。人们希望计算机越来越快，有两种方法，一是提升CPU频率，一是增加CPU数量。

“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”，计算机软件体系结构就是分层的：
{{< image src="/programmer/计算机软件体系结构.png" caption="计算机软件体系结构" width="45%" height="45%">}}

层与层之间通信的协议称为接口，接口下面那层是接口的提供者，接口上面那层是接口的使用者，每个中间层都是对它下面那层的包装和扩展。

多任务系统：OS以进程的方式运行在比系统权限更低的级别，抢占式分配CPU资源，CPU在多个进程间快速切换，造成很多进程都在同时运行的假象。目前几乎所有现代OS都采用这种方式。

设备驱动：OS作为硬件的上层，是对硬件的管理和抽象。我们希望不论硬件型号如何，对应用程序开发者来说，都只需要调用一个统一的函数接口，而不是针对每个型号的硬件都去单独实现。硬件驱动程序是OS的一部分，但交由硬件生产厂商完成。

之后的有关内存的讲述在有了OS基础后都可以看懂，参考OSTEP读书笔记文章。

线程：轻量级进程，是程序执行流的最小单元。一个线程由线程ID、PC指针、寄存器和堆栈组成。使用线程的原因：
1. 等待网络响应，等待的线程会进入睡眠状态，无法继续执行，而多线程执行可以有效利用等待的时间。
2. 耗时长的计算操作，多线程可以让一个线程负责交互，另一个线程负责计算。
3. 程序逻辑本身要求并发操作。
4. 多核计算机本身具备同时执行多个线程的能力，有必要充分发挥。
5. 相对于多进程，多线程在数据共享方面效率很高。
   
线程的私有存储空间：
- 栈
- 线程局部存储（TLS），某些OS为线程单独提供的私有空间，但通常只有有限的容量
- 寄存器，执行流的基本数据

现代OS基本使用多任务系统，多个进程看起来同时运行，每个进程有自己独立的内存资源，CPU在多个进程间快速切换。线程调度自上述多任务系统问世来就不断被提出不同的方案和算法，主流的都带有优先级调度和时间片轮转调度的痕迹。系统会根据线程的表现自动调整优先级，通常情况下，相对于CPU密集型的现程，CPU更喜欢先运行IO密集型的线程，IO密集型的线程涉及频繁的等待。

Windows内核有明确的线程和进程的概念，可以使用明确的API：CreateProcess和CreateThread来创建进程和线程，并有一系列的API来操纵它们。但Linux对多线程的支持颇为贫乏，Linux内核中并不存在真正的线程概念，将所有执行实体都称为任务（Task），不同task之间可以选择共享内存空间，那么这些task就构成了类似的一个进程的多个线程。

过度优化：
1. 编译器为了提高速度将一个变量缓存到寄存器中而不写回。
```C
x = 0;
Thread1    Thread2
lock();    lock();
x++;        x++;
unlock();   unlock();
```
这里两个线程使用了锁来保护共享变量x，但也不一定能保证线程安全。如果Thread1读取x的值到寄存器中，进行了x++操作，但并没有立即写回到内存中，释放了锁；Thread2去读x的值，依旧是0，读的是之前在内存中的值。
1. 编译器调整指令顺序。
```C
x = y = 0;
Thread1    Thread2
r1 = y;    y = 1;
x = 1;     r2 = x;
```
显然，r1和r2至少一个为1，逻辑上不可能为0。然而，编译器在优化时，可能为了效率而不交换毫不相干的两条相邻指令的执行顺序，那么r1=r2=0就完全可能了。
解决办法：使用volatile关键字，volatile可以完美解决第一种情况。但第二种情况，虽然可以阻止编译器调整volatile变量的指令顺序，但无法阻止CPU动态调度换序。
单例模式的double-check：
```C++ 
volatile T* pInst = 0;
T* GetInstance(){
    if(pInst == NULL){
        lock();
        if(pInst == NULL)
            pInst = new T;
        unlock();
    }
    return pInst;
}
```
这里插一下为什么需要double-check，如果不double-check的话，代码是这样的：
```C++ 
volatile T* pInst = 0;
T* GetInstance(){
    if(pInst == NULL){
        lock();
        pInst = new T;
        unlock();
    }
    return pInst;
}
```
如果当前实例为空，就上锁new一个对象，防止多线程同时new多个对象。但是如果两个线程同时判断了pInst == NULL，线程A先拿到锁，new了对象，线程B依旧会执行条件判断里的语句，new一个对象，所以要再次判断。

书中指出，这样的代码依然是有问题的，C++ 的new包含两个步骤：1. 分配内存；2. 调用构造函数。所以pInst = new T;包含三步：1. 分配内存；2. 在内存的位置上调用构造函数; 3. 将内存地址赋值给pInst。CPU乱序执行会导致2、3步骤交换，如果先将地址赋值给pInst，而构造函数还没调用完成，对象没有构造出来，此时并发的调用GetInstance()会发现pInst不为空，从而直接将未构造完成的对象返回给用户使用。对于阻止CPU乱序执行的方法，通常是调用CPU提供的一条指令barrier来保证线程安全。
```C++ 
volatile T* pInst = 0;
T* GetInstance(){
    if(pInst == NULL){
        lock();
        if(pInst == NULL){
            T* temp = new T;
            barrier(); // 保证对象构造完成 再返回地址
            pInst = temp;
        }
        unlock();
    }
    return pInst;
}
```
这里题外话，推荐使用局部静态变量（自带线程安全初始化）来实现单例模式，而不用双检查锁。
```C++ 
T* GetInstance(){
    static T pInst;
    return &pInst;
}
```
多线程内部情况：用户使用的线程并不是内核线程，而是存在于用户态的用户线程。用户线程并不一定在OS内核里对应同等数量的内核线程，例如某些轻量级的线程库，三个用户线程对内核来说可能只有一个线程。
1. 一对一模型，一个用户线程对应一个内核线程，线程之间是真正的并发。一般直接使用API或系统调用创建的线程均为一对一的线程。缺点：用户线程数量受OS限制；内核线程调度上下文开销大，导致用户线程执行效率下降。
2. 多对一模型，将多个用户线程映射到一个内核线程，线程切换由用户态代码进行，快速很多，高效的上下文切换和几乎无限制的线程数量。缺点：其中一个用户线程阻塞，所有线程都将无法执行；处理器增多也不会有明显的性能提升。
3. 多对多模型，将多个用户线程映射到少数但不止一个内核线程上，上述两者模型的折中，优缺点也对应折中。

## 静态链接
### 被隐藏了的过程
{{< image src="/programmer/静态链接过程.png" caption="静态链接过程" width="45%" height="45%">}}

#### 预处理
命令：gcc -E hello.c -o hello.i
- 删除所有的"#define"，并展开所有宏定义
- 处理所有条件预编译指令，如"#if"、"#ifdef"等
- 处理"#include"预编译指令，将被包含的文件插入到该预编译指令的位置
- 删除所有的注释"//"和"/**/"
- 添加行号和文件名标识
- 保留所有的#pragma编译器指令
  
预处理后的.i文件所有宏已经被展开，且包含的文件也已经被插入到.i文件中。当无法判断宏定义是否正确或头文件是否正确时，可以查看预编译后的文件来确定问题。

#### 编译
命令：gcc -S hello.i -o hello.s
具体步骤在下一节简单介绍。
gcc命令只是后台程序的包装，它会根据不同的参数要求去调用预编译编译程序cc1、汇编器as、连接器ld。

#### 汇编
命令：gcc -c hello.s -o hello.o
将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎对应一条机器指令，调用汇编器as来完成。

#### 链接
```Bash
ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc 
-end-group crtend.o crtn.o
```
本书主要介绍上述链接的内容。

### 编译器做了什么
源代码通过词法分析、语法分析、语义分析构建语法树，并进行优化，转为中间代码，它是语法树的顺序表示。中间代码使得编译器可以被分为前端和后端，前端负责产生机器无关的中间代码，后端将中间代码转换成目标机器代码，实现跨平台。代码生成器将中间代码转换为目标代码，这样源代码被编译成了目标代码。

以C语言的源代码为例：`array[index] = (index + 4) * (2 + 6)`为例，它会编译成为目标代码，但目标代码中的index和array的地址还没确定，要把目标代码编译成能在机器上执行的指令，必须要确定index和array的地址。如果index和array跟源代码在同一个编译单元，那么编译器可以为它们分配空间，确定它们的地址。但是如果定义在其他程序模块，最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器将这些目标文件链接起来形成可执行文件。

### 链接器年龄比编译器长
目标文件的指令可能不会一成不变，对应的地址也会发生改变，重新计算各个目标的地址过程叫做重定位。汇编语言将机器指令难以记住的形式变为易于理解记忆的符号，符号用来表示一个地址，这个地址可能是一个变量的其实地址，也可能是一段子程序（函数）的起始地址。不同源代码文件构成不同模块，这些模块组合成程序。最常见的模块通信方式有两种，一种是模块间的函数调用，一种是模块间的变量访问。函数访问需要知道目标函数的地址，变量访问也需要知道目标变量的地址。所以这两种方式都归结为一种，就是模块间符号的引用。这个模块拼接的过程就是链接。

### 模块拼接——静态链接
从原理上讲，它的工作无非就是把一些指令对其他符号地址的引用加以修正。链接过程主要包括了地址和空间分配、符号决议和重定位等这些步骤。

PS：符号决议也可称作符号绑定，决议更倾向于静态链接，绑定更倾向于动态链接。

目标文件和库一起链接形成最终可执行文件，而最常见的库是运行时库，它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放。

main.c模块如果调用了另一个func.c模块的函数foo，在编译时main.c并不知道foo的地址，它暂时搁置，等最后链接的时候链接器填这个foo的地址，而不是手动填。这个地址修正的过程也被叫做重定位，每个要被修正的地方叫一个重定位入口。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。

## 目标文件里有什么
现在PC流行的可执行文件格式主要是Windows下的PE和Linux下的ELF。目标文件跟可执行文件的内容与结构很相似，一般一起采用一种格式存储，可以广义地将目标文件和可执行文件看成是一种类型的文件。动态链接库及静态链接库文件都按照可执行文件格式存储。
{{< image src="/programmer/ELF文件类型.png" caption="ELF文件类型" width="45%" height="45%">}}
{{< image src="/programmer/ELF文件类型续表.png" caption="ELF文件类型续表" width="45%" height="45%">}}

ELF文件格式分段：文件头（文件元数据）、.text段（代码）、.data段（数据）和.bss段（未初始化的全局变量和局部静态变量）。

指令和数据分开的好处：
1. 指令和数据分别被映射到两个虚拟内存区域，数据区是可读可写的，指令区是只读的，对应权限分开。
2. 利于提高程序的局部性，现代CPU缓存设计为数据缓存和指令缓存分离，所以程序的数据和指令分开存放对CPU缓存命中率提高有好处。
3. 最重要的原因，共享指令，系统运行多个该程序的副本时，内存只需要保存一份该程序的指令部分，数据部分是私有的。特别是有动态链接的系统可以节省大量的内存。

Linux命令objdump查看.o文件内部结构，objdump -h把ELF文件的各个段的基本信息打印出来，objdump -s -d将文件内容以十六进制方式打印并将所有指令段反汇编。Linux工具readelf是针对ELF格式的解析器。

在链接中，将函数和变量统称为符号，函数名或变量名就是符号名。每个目标文件都会有一个相应的符号表，表里记录了所有用到的符号，及其对应的地址。除了函数和变量，还存在其他几种不常用到的符号，如定义在本文件中的全局符号、外部符号、段名、局部符号、行号信息。链接只关心全局符号的相互粘合，所以段名、局部符号、行号信息无关紧要。使用nm可以查看.o文件的符号表，打印符号及其地址。

C++  符号修饰：C++  支持函数重载、多态，函数重载是函数同名但参数列表不同，那么编译器和链接器怎么区分这两个函数对应的符号呢？

```C++ 
int func(int);
float func(float);

class C{
    int func(int);
    class C2 {
        int func(int);
    };
};

namespace N {
    int func(int);
    class C {
        int func(int);
    }
}
```

这段代码中有6个同名函数，编译器在将C++ 源代码编译成目标文件时，会将函数和变量的名字进行修饰，形成符号名。上面6个函数签名在GCC编译器下，对应的修饰后名称如下表所示：
{{< image src="/programmer/函数签名.png" caption="函数签名" width="45%" height="45%">}}

它们依照GCC的C++ 名称修饰方法进行修饰，签名和名称修饰机制不光被使用到函数上，全局变量和静态变量也有同样的机制。不同编译器厂商的名称修饰方法也可能不同，有时可能需要将一个修饰后名字转换成函数签名，比如在链接、调试时可能会用到。这里给出几种将符号名转为函数签名的方法：
1. 使用demangler工具（函数签名修饰的过程叫做mangler，反过来叫做demangler）
2. Linux下GCC编译器使用C++ filt命令，如C++ filt _Z4funci命令输出：int func(int)
3. Windows下MSVC编译器使用undname命令

此外，这里也体现了由于不同编译器采用不同的名字修饰方法，必然会导致由不同编译器产生的目标文件无法正常相互连接，这是导致不同编译器之间不能相互操作的主要原因之一。

C++ 为了和C兼容，在C++ 中调用C代码，使用extern "C"关键字用法：
```C++ 
extern "C"{
    int func(int);
    int var;
}
```
这样，extern "C"中的函数和变量就会按照C语言的符号修饰，也就能成功链接到其对应的C函数。

很多时候，我们在引入C语言的库头文件时，文件内又会引用其他C语言函数，比如string.h中声明memset函数，在C语言中的string.h是没有编译问题的，但C++ 调用memset时，会用C++ 符号修饰规则进行修饰，所以必须将memset函数声明为extern "C"，但string.h是C语言，C语言中又不支持extern "C"语法。解决方法是使用C++ 的宏"__cplusplus"，C++ 编译器会在编译C++ 程序时默认定义这个宏。所以在所有头文件中使用该宏定义进行判断是C代码还是C++ 代码来实现：

```C++ 
#ifdef __cplusplus
extern "C"{
#endif

void *memset (void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

## 静态链接过程

当我们有两个目标文件时，如何将它们链接起来形成一个可执行文件？这个过程发生了什么？这就是链接的核心内容：静态链接。可执行文件的代码段和数据段都是由目标文件中合并而来的，那么对于多个可执行文件，链接器如何将它们各自段合并到输出文件？

按序叠加：
{{< image src="/programmer/按序叠加.png" caption="按序叠加" width="45%" height="45%">}}

这样一个规模较大的应用程序可能会有数百个目标文件，就会有成百上千个零散的段，每个段又要做到空间对齐（比如页对齐），造成有大量的内部碎片。

相似段合并：
{{< image src="/programmer/相似段合并.png" caption="相似段合并" width="45%" height="45%">}}

将相同性质的段合并到一起，链接器为目标文件分配地址和空间。这里的地址和空间有两个含义：1. 在输出的可执行文件中的空间；2. 在装载后的虚拟地址中的虚拟地址空间。对于有实际数据的段，比如.text和.data段来说，它们在文件和虚拟地址中都要分配空间；而对于.bss段来说，分配空间只在虚拟地址空间，因为它在文件中并没有内容（这里是指.bss段只是为未初始化的全局变量和局部静态变量预留位置，它没有内容，所以在文件中也不占据空间，未初始化的全局变量和局部静态变量默认值都为0，本来也要放在.data段的，但是因为都是0，所以没有必要在.data中分配空间并全填0，但程序运行时它们的确要占内存空间，并且需要记录所有未初始化的全局变量和局部静态变量的大小总和，记为.bss段）。

两步链接法：
1. 空间与地址分配：扫描所有输入目标文件，并获得各个段的长度、属性和位置，并收集输入目标文件中的符号表，统一放到一个全局符号表中。并且计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
2. 符号解析与重定位：读取输入文件中段的数据、重定位信息，并进行符号解析与重定位、调整代码中的位置。

{{< image src="/programmer/两步链接法.png" caption="两步链接法" width="45%" height="45%">}}
上图将两个.o文件进行合并计算得到虚拟地址空间后，链接器开始计算各个符号的虚拟地址。因为各个符号在段内的相对位置是固定的，所以在上述段起始地址基础上加上符号对应的相对位置偏移量即可。

静态链接的核心内容：符号解析与重定位。

.o文件引用了外部符号，比如"a.c"文件使用了"b.c"文件中的shared变量和swap函数，编译器在编译"a.c"时，会对shared变量地址暂时用"0x00000000"，swap函数地址暂时用"0xFFFFFFFC"替代，把真正的地址计算工作留给了链接器。在经过上一步骤计算得到每个符号的虚拟地址后，就可以重定位上述指令中的外部符号，填为正确的地址。

对于可重定位的ELF文件来说，它必须包含有重定位表，用来描述如何修改相应段里的内容。比如，".rel.text"保存代码段的重定位表，".rel.data"保存数据段的重定位表。

main函数被调用之前，要先初始化进程执行环境，比如堆分配初始化（malloc、free）等，C++ 的全局对象构造函数也是这一时期被执行的。C++ 的全局对象的构造函数在main之前被执行，析构函数在main之后被执行。

Linux系统下一般程序的入口是"_start"，这个函数是Glibc的一部分，当我们的程序与Glibc链接成一个可执行文件后，"_start"就是程序的初始化入口，完成一系列初始化过程之后，会调用main函数执行程序的主体。main函数执行完成后会返回到初始化部分，进行一些清理工作，然后结束进程。因此，ELF文件还定义了两种特殊的段：
- .init段，保存可执行指令，构成进程的初始化代码，在main函数被调用之前，Glibc的初始化部分安排执行这个段的代码
- .fini段，保存进程终止代码指令，在main函数正常退出时，Glibc安排执行这个段的代码

C++ 的全局构造和析构函数就放到上述两个段中，由此实现。

静态链接库可以看成一组目标文件的集合，把零散的目标文件直接提供给库的使用者，很大程度上会造成文件传输、管理和组织的不便，于是人们使用"ar"将这些目标文件压缩到一起，并对其进行编号和索引，以便查找和检索，就形成了libc.a这个静态库文件。使用objdump -t lib.a反汇编查找你想要找的函数符号所在的.o文件。

而且libc.a中的.o文件是存在依赖的，不是只解压其中一个用到的.o文件进行链接就可以，其中的.o文件可能还依赖其他.o文件。直接与lib.a静态库进行链接也是不可以的，还需要用到其他一些辅助性质的目标文件和库。

## 装载与动态链接
由于ELF文件格式的文件是分段的，存在页面对齐的问题，即可能会产生页面内部碎片，在装载时，会将具有相同权限的不同段进行合并。所有相同属性的“Section”被归类为一个“Segment”，并且映射到同一个VMA。当我们谈到ELF装载时，“段”专门指“Segment”；其他情况下，“段”指的是“Section”。
{{< image src="/programmer/ELF文件装载.png" caption="ELF文件装载" width="45%" height="45%">}}

可执行文件最终是要被OS装载运行的，这个装载的过程一般是通过虚拟内存的页映射机制完成的。Linux内核装载ELF文件的过程：用户层面，bash进程调用fork()系统调用创建一个新的进程，然后调用execve()系统调用执行指定的ELF文件，execve()系统调用相应的入口是sys_execve()，它进行一些参数的检查复制之后，调用do_execve()，首先查找被执行的文件，如果找到文件，则读取文件的前128个字节，这前128个字节的目的是判断文件的格式。然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程。每个格式文件有其对应的处理函数，以load_elf_binary()为例，它的主要步骤是：
1. 检查ELF文件格式的有效性
2. 寻找动态链接的“.interp”段，设置动态链接器路径
3. 根据ELF可执行文件的程序头的描述，对ELF文件进行映射
4. 初始化ELF进程环境
5. 将系统调用的返回地址修改为ELF文件的入口点，对于静态链接的ELF文件，入口点是e_entry所指的地址；对于动态链接的ELF文件，入口点是动态链接器
   
所以当sys_execve()系统调用从内核态返回到用户态时，跳转到了ELF程序的入口地址，新的程序开始运行，ELF文件装载完成。

为什么要动态链接？

静态链接的优点：静态链接使得不同的程序开发者和部门能相对独立地开发和测试自己的程序模块，从而大大促进程序开发的效率。

静态链接的缺点：浪费内存和磁盘空间、模块更新困难。
{{< image src="/programmer/静态链接装载.png" caption="静态链接装载" width="45%" height="45%">}}

以上图为例，在静态链接的情况下，Program1和Program2都用到了Lib.o这个模块，当同时运行Program1和Program2时，Lib.o在磁盘和内存中有两份副本。当系统中存在大量的被多个程序共享的目标文件时，其中很大一部分空间就被浪费了。

静态链接的另一个问题是对程序的更新、部署和发布也会带来很多麻烦。比如上图中的Lib.o是由一个第三方厂商提供的，当该厂商更新了Lib.o的时候，那么Program1就需要拿到最新的Lib.o，然后将其与Program1链接后，将新的Program1发布给用户。这样做的缺点是，一旦程序中有任何模块更新，整个程序就要重新链接、发布给用户。如果程序都使用静态链接，那么网络来更新程序将会非常不便。

要解决空间浪费和更新困难这两个问题最简单的办法是把程序的模块互相分割，形成独立地文件。把链接的过程推迟到了运行时再进行，这就是动态链接的基本思想。
{{< image src="/programmer/共享目标文件.png" caption="共享目标文件" width="45%" height="45%">}}

如上图所示，Program2在运行时只需要加载Program1之前加载的Lib.o，而不需要重新加载了，系统要做的只是将Program2.o和Lib.o链接起来。动态链接不仅是节省内存，还可以减少物理页的换入换出，增加CPU缓存的命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上。

动态链接还有一个特点就是程序运行时可以动态选择加载各种程序模块，这个优点就是后来被人们用来制作程序的插件。比如某个产品按照一定的规则制定好程序的接口，其他公司或开发者可以按照这种接口来编写符合要求的动态链接文件。

动态链接还可以加强程序的兼容性，一个程序在不同平台运行时可以动态地链接到OS提供的动态链接库，这些动态链接库相当于在程序和操作系统之间增加了一个中间层，从而消除了程序对不同平台之间依赖的差异性。

动态链接的缺点：当程序所依赖的某个模块更新后，由于新的模块与旧的模块之间接口不兼容，导致原有程序无法运行。在早期Windows版本中，缺乏有效的共享库管理机制，出现“DLL Hell”。

在Linux中，ELF动态链接文件被称为动态共享对象，一般以“.so”为扩展名；而在Windows中，动态链接文件被称为动态链接库，以“.dll”为扩展名。当系统被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。

程序与lib.so之间真正的链接工作是由动态链接器完成的，而不是由我们之前看到的静态链接器ld完成的。动态链接把链接过程从本来的程序装载前被推迟到了装载的时候。这样每次被装载时都要重新进行链接，会带来一些性能损失，相比静态链接，性能损失大约在5%以下，是值得的。

`gcc -fPIC -shared -o Lib.so Lib.c`将Lib.c编译成一个共享对象文件。动态链接过程：
{{< image src="/programmer/动态链接过程.png" caption="动态链接过程" width="45%" height="45%">}}

共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。静态链接的重定位叫做链接时重定位，为了能使共享对象在任意地址装载，能想到的是在链接时，对所有绝对地址的引用不做重定位，推迟到装载时再完成。一旦装载地址确定，系统就对程序中所有的绝对地址引用进行重定位。而这种情况称为装载时重定位。

## Windows下动态链接
整个Windows系统本身即基于动态链接机制，Windows的API也以DLL的形式提供给程序开发者，而不是像Linux等系统是以系统调用作为OS的最终入口。

MSVC编译器可以通过“__declspec”关键字修饰某个函数或变量，使用“__declspec(dllexport)”表示符号是从本DLL导出的符号，使用“__declspec(dllimport)”表示该符号是从别的DLL导入的符号。




---

> 作者: [UAreFree](https://github.com/UAreFree)  
> URL: http://localhost:1313/posts/programmer-note/  

