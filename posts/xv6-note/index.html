<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Xv6读书笔记 -  Blog</title><meta name="author" content="UAreFree">
<meta name="description" content="xv6: a simple, Unix-like teaching operating system (book-riscv-rev4)
操作系统原型——xv6分析与实验 (罗秋明)
"><meta name="keywords" content='xv6, 读书笔记'>
  <meta itemprop="name" content="xv6读书笔记">
  <meta itemprop="description" content="xv6: a simple, Unix-like teaching operating system (book-riscv-rev4)
操作系统原型——xv6分析与实验 (罗秋明)">
  <meta itemprop="datePublished" content="2025-08-30T10:42:57+08:00">
  <meta itemprop="dateModified" content="2025-08-30T10:42:57+08:00">
  <meta itemprop="wordCount" content="14094">
  <meta itemprop="keywords" content="Xv6,读书笔记"><meta property="og:url" content="http://localhost:1313/posts/xv6-note/">
  <meta property="og:site_name" content=" Blog">
  <meta property="og:title" content="xv6读书笔记">
  <meta property="og:description" content="xv6: a simple, Unix-like teaching operating system (book-riscv-rev4)
操作系统原型——xv6分析与实验 (罗秋明)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-30T10:42:57+08:00">
    <meta property="article:modified_time" content="2025-08-30T10:42:57+08:00">
    <meta property="article:tag" content="Xv6">
    <meta property="article:tag" content="读书笔记">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="xv6读书笔记">
  <meta name="twitter:description" content="xv6: a simple, Unix-like teaching operating system (book-riscv-rev4)
操作系统原型——xv6分析与实验 (罗秋明)">
<meta name="application-name" content="YouAreFree">
<meta name="apple-mobile-web-app-title" content="YouAreFree"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" type="text/html" href="http://localhost:1313/posts/xv6-note/" title="xv6读书笔记 -  Blog" /><link rel="prev" type="text/html" href="http://localhost:1313/posts/ostep-note/" title="操作系统导论读书笔记" /><link rel="next" type="text/html" href="http://localhost:1313/about/" title="关于我" /><link rel="alternate" type="text/markdown" href="http://localhost:1313/posts/xv6-note/index.md" title="xv6读书笔记 -  Blog"><link rel="stylesheet" href="/css/config.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "xv6读书笔记",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/localhost:1313\/posts\/xv6-note\/"
    },"genre": "posts","keywords": "xv6, 读书笔记","wordcount":  14094 ,
    "url": "http:\/\/localhost:1313\/posts\/xv6-note\/","datePublished": "2025-08-30T10:42:57+08:00","dateModified": "2025-08-30T10:42:57+08:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "UAreFree"
      },"description": ""
  }
  </script><script src="/js/head/color-scheme.min.js"></script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title=" Blog"><img class="logo" src='/favicon.svg' alt=" Blog" height="32" width="32"><span class="header-title-text"> Blog</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a class="menu-link" href="/archives/"><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 归档</a></li><li class="menu-item">
              <a class="menu-link" href="/categories/"><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a class="menu-link" href="/tags/"><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item">
              <a class="menu-link" href="/about/"><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容……" id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title=" Blog"><img class="logo" src='/favicon.svg' alt=" Blog" height="26" width="26"><span class="header-title-text"> Blog</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容……" id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li class="menu-item"><a class="menu-link" href="/archives/"><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 归档</a></li><li class="menu-item"><a class="menu-link" href="/categories/"><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item"><a class="menu-link" href="/tags/"><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item"><a class="menu-link" href="/about/"><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="fi-container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"><div class="details collection-details open">
      <div class="details-summary collection-summary">
        <i class="fa-solid fa-layer-group fa-fw" aria-hidden="true"></i>
        <span class="collection-name" title="合集">Xv6</span>
        <span class="collection-count">9</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></div>
      <div class="details-content collection-content">
        <nav>
          <ul class="collection-list"><li class="collection-item"><a href="/posts/mit-lab-util/" title="MIT6.1810 Lab:Xv6 and Unix Utilities">MIT6.1810 Lab:Xv6 and Unix Utilities</a></li><li class="collection-item"><a href="/posts/mit-lab-syscall/" title="MIT6.1810 Lab:System Calls">MIT6.1810 Lab:System Calls</a></li><li class="collection-item"><a href="/posts/mit-lab-pgtbl/" title="MIT6.1810 Lab:Page Tables">MIT6.1810 Lab:Page Tables</a></li><li class="collection-item"><a href="/posts/mit-lab-traps/" title="MIT6.1810 Lab:Traps">MIT6.1810 Lab:Traps</a></li><li class="collection-item"><a href="/posts/mit-lab-cow/" title="MIT6.1810 Lab:Copy-on-Write Fork for Xv6">MIT6.1810 Lab:Copy-on-Write Fork for Xv6</a></li><li class="collection-item"><a href="/posts/mit-lab-lock/" title="MIT6.1810 Lab:Locks">MIT6.1810 Lab:Locks</a></li><li class="collection-item"><a href="/posts/mit-lab-fs/" title="MIT6.1810 Lab:File System">MIT6.1810 Lab:File System</a></li><li class="collection-item"><a href="/posts/mit-lab-mmap/" title="MIT6.1810 Lab:Mmap">MIT6.1810 Lab:Mmap</a></li><li class="collection-item"><span class="active" title="Xv6读书笔记">Xv6读书笔记</span></li></ul>
          <div class="collection-nav-simple"><a href="/posts/mit-lab-mmap/" class="collection-nav-item" rel="prev" title="MIT6.1810 Lab:Mmap"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i></a><span class="text-secondary">9/9</span><i class="fa-solid fa-angle-right fa-fw collection-nav-item text-secondary" aria-hidden="true"></i></div>
        </nav>
      </div>
    </div></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>Xv6读书笔记</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://github.com/UAreFree" title="作者"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img class="avatar" src='/blogLogo.jpg' alt="UAreFree" height="16" width="16">&nbsp;UAreFree</a></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category" title="分类 - 操作系统"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> 操作系统</a> 和 <a href="/collections/xv6/" class="post-collection" title="合集 - Xv6"><i class="fa-solid fa-layer-group fa-fw" aria-hidden="true"></i> Xv6</a></span></div><div class="post-meta-line"><span title="发布于 2025-08-30 10:42:57"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2025-08-30">2025-08-30</time></span>&nbsp;<span title="14094 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 14100 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 29 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#xv6-book-chapter-1">xv6 book chapter 1</a></li>
    <li><a href="#xv6-book-chapter-2">xv6 book chapter 2</a></li>
    <li><a href="#xv6-book-chapter-3">xv6 book chapter 3</a></li>
    <li><a href="#xv6-book-chapter-4">xv6 book chapter 4</a></li>
    <li><a href="#xv6-book-chapter-6">xv6 book chapter 6</a></li>
    <li><a href="#xv6-book-chapter-7">xv6 book chapter 7</a></li>
    <li><a href="#xv6-book-chapter-8">xv6 book chapter 8</a></li>
    <li><a href="#xv6fs-文件管理">xv6fs 文件管理</a>
      <ul>
        <li><a href="#文件系统操作">文件系统操作</a></li>
        <li><a href="#非核心功能">非核心功能</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>xv6: a simple, Unix-like teaching operating system (book-riscv-rev4)</p>
<p>操作系统原型——xv6分析与实验 (罗秋明)</p>
<h2 class="heading-element" id="xv6-book-chapter-1"><span>xv6 book chapter 1</span>
  <a href="#xv6-book-chapter-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>xv6实现了Unix所引入的接口，还复刻了Unix的内部架构设计。</p>
<p>当进程需要调用内核服务时，会调用系统调用（OS的一个接口调用），进入内核，内核执行完服务后再返回。当用户调用系统调用时，硬件会提升特权级别并启动内核中预先安排的功能（这里应该指的是trap）。</p>
<p>xv6进程由用户内存空间（指令、数据和堆栈）以及进程状态组成。内核为每个进程分配一个进程标识符（PID），fork创建新进程，会将原进程的内存（包括指令、数据和堆栈）完全复制到新进程中，返回两个参数：在原进程中返回新进程的PID、在新进程中返回零。</p>
<figure><a class="lightgallery" href="/xv6/xv6_syscall.png" title="/xv6/xv6_syscall.png" data-thumbnail="/xv6/xv6_syscall.png" data-sub-html="<h2>xv6 syscall</h2>"><img loading="lazy" src='/xv6/xv6_syscall.png' alt="/xv6/xv6_syscall.png" height="60%" width="60%"></a><figcaption class="image-caption">xv6 syscall</figcaption>
  </figure>
<p>这里system call表中列出了sleep的描述，传入int类型整数，会暂停n个时钟周期。exit终止当前进程，释放资源，传入0表示成功，1表示失败；wait返回子进程exit后的PID，并将子进程的退出状态复制到传入的status参数，如果有子进程则等待一个退出，如果没有子进程立即返回-1;exec会从文件系统中加载一个文件替换调用进程的内存，该文件需为ELF格式，通常是编译程序后的结果，指令会从ELF声明的入口点开始执行，第二参数是字符串参数，通常字符串数组第一个元素是程序名称（被忽略掉），注意exec要求最后一个元素必须是0（NULL）表示参数列表的结束；sbrk将进程内存扩展n个字节，返回新内存的地址；read从文件描述符fd中读取n个字节复制到buf中，并返回已读取的字节数，每个文件描述符都关联一个偏移量，read会从当前文件描述符对应的文件偏移量读取数据，无法读取时返回0表示结束；write会将n个字节从缓冲区写入fd，也会从文件偏移量开始；dup复制一个现有文件描述符，返回一个指向原描述符对象的新描述符，两个描述符共享一个偏移量；pipe创建一个管道，p[0]放读fd，p[1]放写fd。</p>
<h2 class="heading-element" id="xv6-book-chapter-2"><span>xv6 book chapter 2</span>
  <a href="#xv6-book-chapter-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>OS必须满足三大核心要求：多路复用、隔离与交互。xv6运行在多核RISC-V处理器上，RISC-V是一款64位CPU，xv6专为qemu的&quot;-machine virt&quot;选项模拟硬件环境设计，包括内存、ROM、串口、磁盘驱动器等。</p>
<p>某些嵌入式设备或实时OS系统实现的方式是：将系统调用实现为库，供应用程序调用，应用程序可以以这种方式直接与硬件资源交互。当有多个应用程序时，必须定期让出CPU权，这种协作分时机制需要应用程序之间是相互信任的，但更多的是需要隔离的。实现隔离就应避免直接访问硬件资源，而将其抽象为服务。</p>
<p>为实现强隔离机制，OS需要确保：应用程序无法修改OS的数据结构和指令，应用程序无法访问其他进程的内存。硬件上的强隔离：RISC-V具有三种指令模式：机器模式、监督模式（特权指令、内核空间）和用户模式（用户指令、用户空间）。若应用程序需要调用内核函数（系统调用）必须切换至内核模式。为此，RISC-V提供了ecall指令，将CPU切换至内核模式，并通过内核指定的入口点（入口点位置很重要，内核必须能够控制）进入内核。</p>
<p>为了减少内核代码出错导致内核崩溃的可能性，微内核架构尽量减少了内核空间的代码，仅包含启动应用程序、发送消息、访问硬件设备等少数底层功能，其他大部分功能驻留到用户空间中。</p>
<p>将所有系统调用的实现都在监督模式下运行，这种架构是宏内核，整个OS有一个拥有完整硬件特权的单一程序构成，各个组件之间的协作更为便捷。Linux采用的是宏内核，采用微内核架构的OS在嵌入式领域得到广泛使用。xv6采用的是宏内核，虽然整体功能量要比现实工业级的微内核还小。</p>
<p>xv6中隔离的基本单元是进程，每个进程为程序提供看似私有的地址空间以及看似独立的CPU来执行指令。xv6进程虚拟地址最大是0x3fffffffff（MAXVA），在顶端放了一个4096字节的跳转页（trampoline，用户态转为内核态）和陷阱页（trapframe，保存进程用户寄存器），进程最重要的内核状态包括页表、内核栈和运行状态，这些状态信息由proc结构体维护。每个进程又有一个线程，用于保存执行进程所需的状态信息。线程的大部分状态信息（局部变量、函数调用返回地址等）都存储在线程栈中。每个进程有两个栈：用户栈和内核栈，用户态使用用户栈，内核态使用内核栈。可以通过ecall发起系统调用，ecall提升硬件级别，并将PC指向内核定义的入口点，执行入口点的代码，入口点的代码会切换进程的内核栈，并执行实现系统调用的内核指令，执行完成后切换回用户栈，并通过sret指令返回用户空间。</p>
<p>进程通过两种设计思路实现上述两种虚拟化（内存虚拟化和CPU虚拟化），内存虚拟化：虚拟地址空间，CPU虚拟化：线程。在xv6中，进程仅包含一个地址空间和一个线程，实际为充分利用多核CPU会配置多个线程。</p>
<p>xv6内核如何启动并运行第一个进程？当RISC-V开机时，会初始化硬件并运行存储在ROM中的引导加载程序，该程序将xv6内核加载到内存中，然后在机器模式下，从入口点（entry.S）开始执行xv6指令，设置堆栈以便运行start.c代码。函数start会执行一些仅在机器模式下运行的配置操作，然后切换至监督模式（寄存器mstatus），将返回地址设为主程序地址（写入主程序地址到寄存器mepc），禁用监督模式下的虚拟地址转换（向页表寄存器satp写入0），并将所有中断和异常都委托给监督模式处理。主程序main.c初始化多个设备后调用用户初始化函数proc.c创建首个进程，该进程首先执行一段汇编代码initcode.S，加载exec系统调用，将exec系统调用号SYS_EXEC加载到寄存器a7中，然后调用ecall进入内核。内核通过系统调用中a7寄存器的值来调用所需的系统调用函数，exec系统调用会执行exec(&quot;/init&quot;)替换当前进程的内存和寄存器，init进程会在需要时创建一个新的控制台设备文件（开启文件描述符0、1、2），接着在控制台上启动一个shell，系统就启动了。</p>
<p>用户调用如何传递到内核中的exec系统调用实现？初始化代码.S将exec的参数存入寄存器a0和a1，并将系统调用号存入a7，ecall进入内核，依次执行uservec、usertrap和system call操作，system call从陷阱页中保存的a7读取系统调用号，从而执行对应的system call。返回时，将返回值记录在p-&gt;trapframe-&gt;a0中，就导致用户空间的exec()调用返回该值。</p>
<p>内核中系统调用参数是用户代码传递的参数，这些参数会放在寄存器中，内核trap代码会将用户寄存器保存到当前进程的陷阱页中，以便内核代码进行提取。内核函数argint、argaddr、argfd会从陷阱页中提取系统调用参第n个数，同时调用argraw来获取相应的用户寄存器保存值。</p>
<h2 class="heading-element" id="xv6-book-chapter-3"><span>xv6 book chapter 3</span>
  <a href="#xv6-book-chapter-3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>xv6主要用了两种技巧：1. 将相同内存（trampoline）映射到多个地址空间；2. 用未映射页来保护内核堆栈和用户堆栈。</p>
<p>xv6基于Sv39 RISC-V运行，使用了低39位的虚拟地址。而这39位又划分为低12位及剩余的27位，27位可构成2^27个页表项（PTE），对应转换为44位的物理地址，低12位则为偏移量，直接复制到物理地址的低12位。</p>
<figure><a class="lightgallery" href="/xv6/%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2.png" title="/xv6/地址转换.png" data-thumbnail="/xv6/地址转换.png" data-sub-html="<h2>地址转换</h2>"><img loading="lazy" src='/xv6/地址转换.png' alt="/xv6/地址转换.png" height="60%" width="60%"></a><figcaption class="image-caption">地址转换</figcaption>
  </figure>
<p>RISC-V CPU具体将虚拟地址转为物理地址的步骤：</p>
<ol>
<li>页表以三级树状结构存储在物理内存中（注意，页表存在物理内存中，没存在虚拟内存，也没存在MMU中），每一级页表大小是4KB，占一页，内含512（2^9）个页表项。</li>
<li>将上述27位虚拟地址划分为3个9位，每9位选择每级页表中的页表项。如果所需的三个PTE中任何一个不存在，分页硬件会引发分页错误异常，并由内核处理该异常。与单级页表相比，三级页表能节省较大的内存空间，比如当应用程序仅使用从地址零开始的少数页面时，顶层目录中的1至511号条目将失效，内核无需为这些条目分配中间目录，也就无需分配对应的底层页面，从而为中间目录节省了511个页面，为底层目录节省了511*512个页面。</li>
<li>这样虽然节省了页面，但增加了CPU加载PTE的开销，每次要读取3个PTE，为避免开销，会将PTE缓存在TLB中。</li>
<li>每个PTE的低10位是标志位，用于告知分页硬件如何使用相关虚拟地址，如是否有效、是否可读、是否可写等。</li>
<li>要让CPU使用页表，就要将顶层页目录的物理地址写到satp寄存器中，从而读取到顶层页目录的内容进行后续查表。每个CPU有自己的satp寄存器，从而实现拥有自己的虚拟地址空间，进而同时运行不同的进程。
<figure><a class="lightgallery" href="/xv6/%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8.png" title="/xv6/多级页表.png" data-thumbnail="/xv6/多级页表.png" data-sub-html="<h2>多级页表</h2>"><img loading="lazy" src='/xv6/多级页表.png' alt="/xv6/多级页表.png" height="60%" width="60%"></a><figcaption class="image-caption">多级页表</figcaption>
  </figure></li>
</ol>
<p>内核页表只有一个，大部分直接映射到物理内存，从KERNBASE（0x80000000）开始到PHYSTOP（0x88000000）这部分是QEMU模拟的地址空间范围，主要存放kernel的代码段、数据段、堆区；在KERNBASE之下将IO设备接口以内存映射寄存器的方式暴露给软件，直接与硬件通信；trampoline和栈页不是直接映射的，由于栈页放在了虚拟地址的高地址，因此保留了一个未映射的保护页，当内核栈溢出时会触发异常。</p>
<figure><a class="lightgallery" href="/xv6/%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e6%98%a0%e5%b0%84.png" title="/xv6/地址空间映射.png" data-thumbnail="/xv6/地址空间映射.png" data-sub-html="<h2>地址空间映射</h2>"><img loading="lazy" src='/xv6/地址空间映射.png' alt="/xv6/地址空间映射.png" height="60%" width="60%"></a><figcaption class="image-caption">地址空间映射</figcaption>
  </figure>
<p>代码层面上，以kvm开头的操作内核页表，以uvm开头的操作用户页表，其他同时用于两者。RISC-V中包含一个名为sfence.vma的指令，用于刷新当前CPU的TLB，xv6会在重新加载satp寄存器之后，trampoline切换用户页表回到用户空间之间执行该指令（刷新内核页表的TLB）。kalloc维护物理内存链表，kinit将空闲链表初始化为内核结束到PHYSTOP之间的每个页面，kfree会将释放内存中每个字节都设为1，然后将该页添加到空闲链表头。</p>
<p>用户页表针对每一个进程都有一个自己的页表，用户空间从0开始可扩展至MAXVA，通过设置PTE权限是强化用户进程安全的常用技术。用户栈空间占一页，栈顶包含命令行参数的字符串即指向这些参数的指针数组，紧邻下方的值允许程序像刚调用函数main(argc, argv)一样直接从main函数开始执行。同时为检测栈溢出，在栈下方设置了不可访问的保护页，当栈溢出并尝试使用保护页的地址时会生成页面错误异常。
<figure><a class="lightgallery" href="/xv6/%e7%94%a8%e6%88%b7%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4.png" title="/xv6/用户地址空间.png" data-thumbnail="/xv6/用户地址空间.png" data-sub-html="<h2>用户地址空间</h2>"><img loading="lazy" src='/xv6/用户地址空间.png' alt="/xv6/用户地址空间.png" height="60%" width="60%"></a><figcaption class="image-caption">用户地址空间</figcaption>
  </figure></p>
<h2 class="heading-element" id="xv6-book-chapter-4"><span>xv6 book chapter 4</span>
  <a href="#xv6-book-chapter-4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有三种情况CPU会放弃当前常规指令然后强制执行特殊代码处理事件：</p>
<ol>
<li>系统调用：用户程序执行ecall指令陷入内核</li>
<li>异常：用户或内核指令执行非法操作（除以零或使用无效虚拟地址）</li>
<li>中断：当设备发出中断信号触发（磁盘硬件完成读写请求）</li>
</ol>
<p>将上述这些情况称为陷阱trap，典型的处理流程是：trap强制将控制权转移至内核；内核保存寄存器等状态信息；内核执行相应的处理程序代码；内核恢复保存的寄存器状态并返回；原始代码继续从断点处执行。</p>
<p>分为用户空间陷阱和内核空间陷阱，处理陷阱的内核代码称为处理程序handler，处理程序的前条指令使用汇编vector。</p>
<p>RISC-V CPU所配备的寄存器：</p>
<ol>
<li>stvec：内核写入陷阱处理程序trap handler的地址</li>
<li>sepc：保存程序计数器pc的值</li>
<li>scause：触发trap的原因</li>
<li>sscratch：避免在保存用户寄存器时覆盖陷阱处理程序</li>
<li>sstatus：SIE位控制是否启用设备中断；SSP位指示trap来自用户模式还是特权模式</li>
</ol>
<p>CPU硬件在trap的时候是会保存程序计数器pc，其他交由内核软件完成。</p>
<p>从用户空间触发trap的路径是：uservec(trampoline.S)-&gt;usertrap(trap.c)，返回路径是：usertrapret(trap.c)-&gt;userret(trampoline.S)。因为在trap时，CPU硬件不会更换页表，所以在用户页表上必须要有trap handler地址的映射。在找到trap handler物理地址执行对应代码时也要实现切换为内核页表，内核页表也必须要有trap handler地址的映射。</p>
<p>trampoline页包含用户空间中的trap handler代码，在每个进程的页表中都映射到了TRAMPOLINE地址上。同时也映射在内核页表中的TRAMPOLINE地址上。uservec执行时，所有32个寄存器都被占用，需要把这32个通用寄存器的值存到内存中，然而将寄存器的值保存到内存中需要一个寄存器保存地址才行，在中断开始的csrw指令会将a0寄存器的值存到sscratch寄存器中，这样就腾出a0寄存器来操作了。把a0寄存器的值设为trapframe的地址，这样所有32个寄存器的值就保存在了trapframe中。trapframe还包含当前进程的内核栈、当前CPU的hartid、usertrap函数的地址和内核页表地址。</p>
<p>许多内核通过页错误机制实现写时复制版的fork，在fork时子进程和父进程共享相同的物理内存。当虚拟地址在页表中不存在映射，或PTE_V标志位被清除，或权限位禁止操作时，CPU会触发页面错误异常。RISC-V将页错误分为三类：加载页错误、存储页错误、指令页错误，scause寄存器表示页错误类型，stval寄存器保存错误地址。</p>
<p>COW的基本方案是父进程和子进程共享所以物理页，但是设置只读映射，不设置PTE_W。若任一进程写入特定页就会触发页面错误异常，trap handler会分配新的物理内存页面并将出错地址对应的物理页面内容复制到该页面，并修改相关PTE的权限为可读可写。注意这里需要增加引用计数，统计一个物理页面被多少进程页表所映射，以便正确释放。COW让fork更快，因为不需要复制大部分物理内存，通常大部分内存根本无需复制，典型例子是fork后exec；以及COW具有透明性，应用程序无需修改即可受益。</p>
<p>页表分页与页面错误机制结合除了上述COW版的fork外还有一个广泛应用的功能是延迟分配（懒分配）。1. 调用sbrk()系统调用申请更多内存时，内核会记录虚拟地址范围的扩展，但不会立即分配物理内存，也不会为新增的虚拟地址范围创建PTE；2. 当这些新地址中的某个页面发生错误时，内核会分配一个物理内存页并将其映射到页表中。</p>
<p>另一个应用页面错误机制的是按需分页，在exec中，为了缩短启动时间，内核不会一开始就将可执行文件加载到内存中，而是创建用户页表将所有PTE标记为无效，每当程序首次使用某个页面时，就会发生页面错误，此时再从磁盘读取该页面的内容并将其映射到用户地址空间。</p>
<p>虚拟内存为进程提供了看似更大的地址空间，这使用到了磁盘，使用磁盘分页，将部分用户页面存到磁盘中，并将PTE标记为无效，当访问这些页面时，错发页面错误，trap handler会分配一个内存页，从磁盘读取该页面到内存，并修改相关的PTE。</p>
<h2 class="heading-element" id="xv6-book-chapter-6"><span>xv6 book chapter 6</span>
  <a href="#xv6-book-chapter-6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>并发指的是多处理器并行、线程切换或中断导致的多指令流交错执行场景。内核中充斥大量需要并发访问的数据，例如，两个CPU可能同时调用kalloc函数，从而并发地从空闲链表弹出头结点。锁通过互斥机制确保同一时间只有一个CPU能持有该锁，若程序员为每个共享数据关联一个锁，并在访问数据时始终持有相应锁，那么该数据就能保证同一时间只被一个CPU访问。锁作为并发控制机制易于理解，但缺点在于可能限制性能——锁会导致并发操作被串行化处理。</p>
<p>竞态条件指多个操作并发访问同一内存地址且至少包含一个写操作的情形。竞态结果取决于编译器生成的机器码、CPU的时序调度以及内存系统对内存操作的重排。这些因素使得由竞态引发的错误极难复现和调试。获取和释放之前的指令序列通常被称为临界区。</p>
<p>内核设计的一大挑战是通过避免锁争用实现并行性，复杂的内核会专门设计数据结构和算法来避免锁争用。以链表为例，内核可能为每个CPU维护独立空闲链表，仅当当前CPU的链表为空且必须从其他CPU窃取内存时，才会触及到其他CPU的空闲链表。</p>
<p>xv6有两种锁：自旋锁和休眠锁。下边acquire的实现无法确保多处理器下的互斥，可能会出现两个CPU同时执行到第5行代码，然后这两个CPU同时持有锁。需要将第5行和第6行代码改为原子操作。在RISC-V中，原子指令是<code>amoswap r, a</code> 这条指令原子性的交换了寄存器和内存的值，通过特殊硬件来保证的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">spinlock</span><span class="o">*</span> <span class="n">lk</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(;;){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>锁和中断处理函数：假设sys_sleep持有ticksclock时，其CPU被定时器中断打断，clockintr会尝试获取tickslock，发现已被持有并等待释放。但这时候tickslock将永远无法释放，只有sys_sleep才能释放它，但sys_sleep必须等到clockintr返回时才能继续运行，于是CPU将陷入死锁。为避免这种情况，若中断处理程序使用自旋锁，CPU必须确保在启用中断时不持有该锁。xv6采取的策略是：当CPU获取锁时，禁用该CPU的中断。当CPU不持有锁时，xv6会重启中断。acquire调用push_off，release调用pop_off来追踪当前CPU上的锁嵌套层级。当计数器归零时，pop_off会恢复最外层临界区开始时的中断启用状态。intr_off和intr_on函数分别执行RISC-V指令来禁用和启用中断。</p>
<p>多线程下程序指令会出现乱序问题，原因之一是编译器生成的加载和存储指令顺序与源代码顺序不同，原因之二是CPU可能会乱序执行指令以提高性能。为了告知硬件和编译器不要进行指令重排序，xv6在acquire和release中都使用了__sync_synchronize()，__sync_synchronize()是一种内存屏障：它告诉编译器和CPU不要跨屏障重新排序加载或存储操作。由于xv6在访问共享数据时都使用了锁，其acquire和release中的屏障在几乎所有关键场景中都强制保证了执行顺序。</p>
<p>若一个进程试图获取自旋锁，长时间持有会导致资源浪费，因为获取进程会在自旋过程中空转CPU，且进程持有自旋锁时无法让出CPU。需要一种能在等待获取时以及持有锁时让出CPU的锁。xv6通过睡眠锁实现，acquiresleep函数在等待时会释放CPU使用权，从而使得其他线程能够继续执行。</p>
<p>Real world中提到用锁编程充满挑战，若用锁编程，明智的做法是使用能检测竞态条件的工具。虽然无需原子指令也能实现锁机制，但这种方式代价太高，因此绝大多数OS仍选择采用原子指令。为避免锁带来的开销，许多OS采用无锁数据结构和算法，但无锁编程比基于锁的编程更为复杂，例如必须考虑指令与内存重排序的问题。</p>
<h2 class="heading-element" id="xv6-book-chapter-7"><span>xv6 book chapter 7</span>
  <a href="#xv6-book-chapter-7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>OS运行的进程数往往大于CPU数量，所以需要多路复用机制来实现在进程看来拥有自己独立的CPU。</p>
<p>xv6通过两种机制实现多进程并发：1. 当进程发出阻塞系统调用时，xv6的睡眠和唤醒机制会自动切换CPU；2. 针对长期运行但不会阻塞的进程，xv6会定期进行CPU切换。前者属于自愿切换，后者属于非自愿切换。</p>
<p>用户进程切换的完整流程：首先trap进内核，进行上下文切换至当前CPU的调度线程，随后再次切换到新进程的内核线程，最终返回用户进程。xv6通过独立线程（保存寄存器和堆栈）来执行调度程序，因为让调度程序直接在任意进程的内核堆栈上运行存在安全隐患，其他CPU可能随时唤醒并运行该进程，若两个不同的CPU使用同一堆栈将引发灾难性后果。每个CPU都有专门的调度线程，处理多个CPU同时运行且需要释放资源的进程。</p>
<p>从一个线程切换到另一个线程需要保存旧线程的CPU寄存器，并恢复新线程之前保存的寄存器；由于堆栈指针和程序计数器被保存和恢复，意味着CPU将切换堆栈并切换正在执行的代码。</p>
<p>swtch函数保存并恢复寄存器（上下文），当进程放弃CPU时，进程内核线程会调用swtch函数保存它自己的上下文并恢复调度器的上下文。每个上下文都包含在context结构体中，该结构体又包含在进程的proc结构体或CPU的结构体cpu中。swtch函数接受两个参数：context* old和context* new，它保存当前的old，加载new中的寄存器并返回。</p>
<p>usertrap其中之一是yield，yield会调用sched，sched会调用swtch保存当前上下文到p-&gt;context中，并切换之前保存在cpu-&gt;context中的调度器上下文。</p>
<p>swtch没有保存程序计数器，而是保存ra寄存器，该寄存器保存调用swtch的返回地址。当swtch返回时，它会返回到ra寄存器保存的返回地址，即之前调用swtch的新线程。此外，swtch也会返回sp堆栈指针指向的线程栈。</p>
<p>每个CPU都有一个专用线程作为调度器，运行scheduler函数，选择下一个要运行的进程。当进程想要让出CPU时必须获取它自己的锁p-&gt;lock，释放它持有的其他锁，更新它自己的状态p-&gt;state，然后调用sched函数。这个操作流程同样存在于yield、sleep和exit函数中。sched调用swtch保存当前上下文p-&gt;context，切换调度器上下文cpu-&gt;context。随后调度器一直循环，找到要运行的进程并切换，如此循环往复。</p>
<p>scheduler运行一个循环：找到一个进程来运行，运行它知道让出，重复。scheduler遍历进程表寻找可运行的进程，即p-&gt;state == RUNNABLE的进程。一旦找到一个进程，就设置每个CPU的当前进程变量c-&gt;proc，将进程标记为RUNNING，然后调用swtch启动运行。</p>
<p>睡眠和唤醒：信号量PV操作作为条件同步的一种机制，xv6中信号量维护计数并提供两种操作：V操作（生产者）增加计数值，P操作（消费者）减少计数值。如果只有一个生产者一个消费者线程，其最初实现为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">semaphore</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semphore</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semphore</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种实现P操作一直自旋，为了避免陷入忙等待，可以使用sleep调用将调用进程置于睡眠状态和wakeup调用唤醒进程，实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">semaphore</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semphore</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semphore</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是这样存在虚假唤醒的问题，进程A在P操作判断s-&gt;count == 0之后，sleep之前，另一进程B同时调用了V操作增加count并wakeup，导致此时进程A没有被唤醒。然后进程A继续执行P操作从而sleep睡眠。为了避免虚假唤醒，可以在P操作判断s-&gt;count == 0时也加上锁。比如如下实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">semaphore</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semphore</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semphore</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但这样很明显又会带来死锁问题，进程B在执行P操作时睡眠持有锁，进程A永远无法拿到锁执行V操作，所以需要再sleep中传入锁，当进程被标记为睡眠状态并在睡眠通道等待时，sleep释放锁。最后的实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">semaphore</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semphore</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semphore</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 class="heading-element" id="xv6-book-chapter-8"><span>xv6 book chapter 8</span>
  <a href="#xv6-book-chapter-8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>xv6文件系统提供了类Unix的文件、目录和路径名，并将其数据持久化储存在virtio磁盘上。xv6的文件系统解决的几个挑战：</p>
<ol>
<li>需要磁盘上的数据结构来标识目录、文件，记录哪些磁盘块是空闲的、哪些是对应文件的（使用inode、idnode、dirent等）</li>
<li>必须支持崩溃恢复（使用事务、日志）</li>
<li>必须维护并发下的临界区（使用锁）</li>
<li>必须维护一个内存与磁盘之间的缓存（使用buffer cache）
采用七层组织架构，磁盘层负责在virtio硬盘驱动器上读写数据块。缓冲区缓存层对磁盘块进行缓存，并同步访问操作，确保同一时间只有一个内核进程能够修改特定数据块中存储的信息。日志层允许上层将多个数据块的更新打包成事务处理，并确保在系统崩溃时这些数据块能以原子方式更新（即要么全部更新成功，要么完全不更新）。索引节点层提供独立文件，每个文件由具有唯一索引编号（i-number）的inode和存储文件数据的若干数据块表示。目录层将每个目录实现为一种特殊类型的inode，其内容是由目录项组成的序列，每个目录项包含文件名和索引编号。路径名层支持如/usr/rtm/xv6/fs.c这样的层级路径命名，并通过递归查找进行解析。文件描述符层利用文件系统接口对多种Unix资源（如管道、设备、文件等）进行抽象，从而简化应用程序员的工作。
<figure><a class="lightgallery" href="/xv6/%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84.png" title="/xv6/文件系统组织结构.png" data-thumbnail="/xv6/文件系统组织结构.png" data-sub-html="<h2>文件系统组织结构</h2>"><img loading="lazy" src='/xv6/文件系统组织结构.png' alt="/xv6/文件系统组织结构.png" height="60%" width="60%"></a><figcaption class="image-caption">文件系统组织结构</figcaption>
  </figure>
磁盘硬件呈现为512个字节的块序列（每个扇区512字节），OS使用的块大小通常是扇区大小的整数倍,xv6块大小为1024字节。文件系统将磁盘划分为若干区域，如下图所示：
<figure><a class="lightgallery" href="/xv6/xv6%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%bb%84%e7%bb%87.png" title="/xv6/xv6文件系统组织.png" data-thumbnail="/xv6/xv6文件系统组织.png" data-sub-html="<h2>xv6文件系统组织</h2>"><img loading="lazy" src='/xv6/xv6文件系统组织.png' alt="/xv6/xv6文件系统组织.png" height="60%" width="60%"></a><figcaption class="image-caption">xv6文件系统组织</figcaption>
  </figure>
Buffer cache有两个主要功能：</li>
<li>实现对磁盘块的同步访问，确保内存中只保留一个块副本，且同一时间只有一个内核线程使用该副本；</li>
<li>缓存高频访问块，避免从低速磁盘重复读取。相关代码位于bio.c文件中。
Buffer cache主要接口：</li>
<li>bread，从磁盘中获取包含块副本的buf结构；</li>
<li>bwrite，将修改后的缓冲区写入磁盘对应块；</li>
<li>brelse，释放一块buffer的睡眠锁，在bread时会acquire对应buffer的锁，这里要释放。每个buffer有其睡眠锁，而整个buffer cache链表有一把大锁bcache.lock，这个锁在对整个buffer cache链表进行操作时要acquire。sleep lock保护的是块的buffer内容读写，而bcache.lock保护的是所有被缓存块的信息。
Buffer cache的维护使用LRU策略，基于双向循环链表，链表head节点是最新的buffer、head节点前一个节点是最久未被使用的buffer。所以从head节点向后遍历是找最近使用的buffer，向前遍历是找最近最少使用的buffer，一般会踢出最近最少使用的buffer，然后向head之后插入新的buffer。
系统崩溃问题的出现是对磁盘写入时，只执行了部分写操作，从而使磁盘上的文件系统处于不一致的状态。
xv6通过一种简单的日志记录形式解决了文件系统崩溃问题。syscall不会直接写入磁盘上的文件系统数据结构，而是会将所有写入操作记录到磁盘的日志中。当syscall完成所有写入操作的日志记录后，会向磁盘写入一个commit，表明该日志包含完整的操作。此时，syscall会将这些写入操作复制到磁盘的文件系统数据结构中。等这些写入完成后，syscall将擦除磁盘上的日志。日志能确保在崩溃时具有原子性：恢复后，要么操作的所有写入都出现在磁盘上，要么一个都不会出现。</li>
</ol>
<p>个人感觉xv6的文件系统比较复杂，涉及很多代码，不像之前的内存管理、虚拟化CPU，是理解上抽象，但有逻辑，不复杂。而文件系统部分需要仔细阅读众多函数源码后才能更好的理解，xv6 book只用了一章来讲解了这个复杂的系统，所以在此阅读《操作系统原型——xv6分析与实验》的文件管理部分进行补充。</p>
<h2 class="heading-element" id="xv6fs-文件管理"><span>xv6fs 文件管理</span>
  <a href="#xv6fs-%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>静态概念：磁盘文件系统的格式及其细节。</p>
<p>动态概念：用户进程通过系统调用访问磁盘数据的过程及其所使用的代码。</p>
<p>文件的逻辑结构：用户进程看来是一个线性可寻址的字节集合，只要给出具体的偏移量就可以访问到文件的任意内容。具体到操作系统文件则是使用file结构体表示，pos成员表示偏移量。在文件逻辑层维护了file文件结构体数组，其使用inode、dinode作为文件索引，对应到磁盘的块。类似于页表将虚拟内存地址映射到物理内存地址，inode索引将逻辑文件映射到物理磁盘块上。
<figure><a class="lightgallery" href="/xv6/%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84.png" title="/xv6/文件结构.png" data-thumbnail="/xv6/文件结构.png" data-sub-html="<h2>文件结构</h2>"><img loading="lazy" src='/xv6/文件结构.png' alt="/xv6/文件结构.png" height="60%" width="60%"></a><figcaption class="image-caption">文件结构</figcaption>
  </figure></p>
<p>xv6磁盘文件系统的布局：启动块、超级块、日志块、inode块、位图块、数据块。其中超级块记录日志块、inode块、位图块、数据块的起始块号和数量。
<figure><a class="lightgallery" href="/xv6/%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%bb%84%e7%bb%87.png" title="/xv6/文件系统组织.png" data-thumbnail="/xv6/文件系统组织.png" data-sub-html="<h2>文件系统组织</h2>"><img loading="lazy" src='/xv6/文件系统组织.png' alt="/xv6/文件系统组织.png" height="60%" width="60%"></a><figcaption class="image-caption">文件系统组织</figcaption>
  </figure></p>
<p>目录也是文件，不过内容是（inode num，path）形式的目录项，指向了多个文件，也就形成了树状结构，相对于扁平的，更具有层次性。目录的前两个目录项都是一致的，是“.”和“..”，分别指向自己和父目录，那我们在查找文件时，输入path，就可以按照路径名从目录树中自顶向下查找，目录也是文件说明它也要有父目录，目录项指向它，这样有目录就必须要有父目录，为了避免这种先鸡后蛋的问题，定义根目录“/”（这个斜杠和除号一样，不是反斜杠）的inode为1，这样固定了根目录节点的inode就可以。</p>
<p>由之前的章节我们知道，OS对文件的读写操作都是针对文件描述符的，所以进程操作的是文件描述符，而不是上述的file结构体或是inode结构体。xv6每个进程都有一个文件描述符表proc-&gt;ofile[]，每个文件描述符都指向了一个ftable的file结构体，这里为什么又增加一层，是因为文件描述符与file可能是多对一的关系，多个文件描述符可能指向同一个文件。
<figure><a class="lightgallery" href="/xv6/%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6%e8%a1%a8.png" title="/xv6/文件描述符表.png" data-thumbnail="/xv6/文件描述符表.png" data-sub-html="<h2>文件描述符表</h2>"><img loading="lazy" src='/xv6/文件描述符表.png' alt="/xv6/文件描述符表.png" height="60%" width="60%"></a><figcaption class="image-caption">文件描述符表</figcaption>
  </figure></p>
<p>dinode结构体包含type类型，可能是目录、磁盘文件、设备；nlink记录有多少目录项指向了该dinode，实际上代表这个文件有多少路径名；address数组，元素内容是磁盘块号，也就组织起来了一堆块为该dinode文件所属。书中的indirect block有128个元素，而xv6源码（2024）中是有256个元素的。
<figure><a class="lightgallery" href="/xv6/dinode%e7%bb%93%e6%9e%84.png" title="/xv6/dinode结构.png" data-thumbnail="/xv6/dinode结构.png" data-sub-html="<h2>dinode结构</h2>"><img loading="lazy" src='/xv6/dinode结构.png' alt="/xv6/dinode结构.png" height="60%" width="60%"></a><figcaption class="image-caption">dinode结构</figcaption>
  </figure></p>
<h3 class="heading-element" id="文件系统操作"><span>文件系统操作</span>
  <a href="#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>上节所述的是文件系统的大体结构，本节自底向上讨论文件系统的操作。</p>
<p>书中有一句：xv6使用了日志系统，因此所有写操作都是通过log_write()完成的，但是读操作并不需要日志系统。</p>
<p>由于磁盘块的读写操作比较慢，因此使用内存中的块缓存来加快其访问速度，例如对一个块的多次写操作可以在内存中完成，直到换出到磁盘上才真正执行写操作。xv6块缓存使用bcache结构管理30个块缓存buffer，单个buffer使用buf结构体，包含设备号、块号、前驱结构体指针、后继结构体指针、块数据。而这30个块缓存使用双向链表来维护，链表头结点指向最近使用的buffer，头结点的前驱指向最近最少使用的buffer，bcache互斥锁维护双向链表的bcache。块缓存的查找和释放使用bget()和brelse()。</p>
<p>块的读写操作bread()和bwrite()是文件系统最基本的操作。当要读入一个盘块数据时，回先bget()得到块缓存；writei()调用bwrite()之前会调用bread()得到块缓存，然后再去写。</p>
<p>为了加快索引节点的读写操作，xv6也会建立inode的缓存，dinode是磁盘的inode、inode是内存缓存的inode，inode在上述dinode结构体基础上增加了部分成员变量，如dev设备号、inum号、ref引用计数、lock睡眠锁、valid标志位等（这里2024xv6源码与此书不同，明显是有所更改），这里的ref引用计数是指有多少个打开的文件使用该inode，也就是上层file指向此inode的数量，注意与nlink区分。</p>
<p>文件读写操作：readi()从inode对应的文件偏移off处，读入n个字节到dst指向的数据缓冲区，先通过bmap()找到对应的物理块号；writei()先调用bread()将磁盘块读入到块缓存，再将数据复制到块缓存中，最后由log_write()向日志系统写出。</p>
<p>xv6的struct file是对inode的一次动态抽象和封装。对file而言，文件内容是一维的字节数组，可以用偏移量访问文件中的任意数据。向上与文件描述符表建立联系，向下与inode相关联。file特指磁盘文件的一次动态打开，是动态概念，而inode代表的磁盘文件则是静态概念。</p>
<p>这部分的代码太多了，很多函数，很难一一记录。此书也是粘贴了大部分源代码做注释，个人的话还是建议直接读xv6的代码结合书上的函数大意来理解。再次就不再赘述了，只是需要回答以下几个问题来掌握文件系统的组织脉络。</p>
<ol>
<li>文件怎么创建的？
sys_open()-&gt;create()，找到path对应的父目录，为其添加目录项，ialloc()分配inode，并调用filealloc()分配空闲的file对象，fdalloc()分配对应的文件描述符。</li>
<li>文件怎么删除的？
file.c作为上层syscall和下层inode的中间层，提供fileclose()，它会判断file的ref是否为1（只有一个syscall使用该file），如果是，会调用iput()尝试释放inode，在inode的nlink为0（没有path指向它）时，会真正释放inode，同时调用bfree()把对应的磁盘块释放掉。</li>
<li>文件怎么读？
同样file.c提供fileread()，对于磁盘文件调用readi()，传入file对应的inode和偏移量，然后去调用bread()读取磁盘块。</li>
<li>文件怎么写？
file.c提供filewrite()，然后调用writei()，传入file对应的inode和偏移量，以及为防止一次写入的数据超过日志系统的上限，一次最多写入max个字节，如果超过将分成多次写入。writei()调用log_write()，写入操作还是先写到日志上去。函数调用链是：write()-&gt;sys_write()-&gt;filewrite()-&gt;writei()-&gt;log_write()。而在文件读写前都要sys_open()文件得到文件的描述符，sys_open()对于创建文件会使用create()打开文件。否则通过namei()查找对应的inode，然后由filealloc分配文件对象，最后fdalloc()创建文件描述符。</li>
</ol>
<h3 class="heading-element" id="非核心功能"><span>非核心功能</span>
  <a href="#%e9%9d%9e%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这里指日志功能，xv6文件系统的日志确保写操作不会导致文件系统的破坏，进程的写操作是一种原子操作，要么全部完成，要么全不执行。当修改了内存中的块缓冲区后，log_write()同时在block数组中记录这个块需要写到磁盘的哪一块，但是没有立即写，当调用commit()时，调用write_log()将待写入的数据保存在日志区盘块上，并调用write_head()更新磁盘的日志记录，最后调用install_trans()真正的更新文件系统。此时，若发生崩溃会导致日志有非零的计数，以便重启后再次进行写操作，最后将计数变量置零，使日志失效并更新日志初始块。xv6日志读写支持并发操作，begin_op()检查日志是否在提交，如果在提交，则睡眠当前进程；如果不在提交，当没有任何进程操作log时调用commit提交日志。
<figure><a class="lightgallery" href="/xv6/%e6%97%a5%e5%bf%97%e5%8c%ba.png" title="/xv6/日志区.png" data-thumbnail="/xv6/日志区.png" data-sub-html="<h2>日志区</h2>"><img loading="lazy" src='/xv6/日志区.png' alt="/xv6/日志区.png" height="60%" width="60%"></a><figcaption class="image-caption">日志区</figcaption>
  </figure></p>
<p>这个示意图在2024的xv6源码中应该是日志区在前，数据块在后，和上边所述的位置也不一致。不过不影响示意，其含义就是header记录了30个log块，block的内容是要写入的块位置。下图是对应的日志写盘过程。
<figure><a class="lightgallery" href="/xv6/%e6%97%a5%e5%bf%97%e5%8a%9f%e8%83%bd%e7%a4%ba%e6%84%8f.png" title="/xv6/日志功能示意.png" data-thumbnail="/xv6/日志功能示意.png" data-sub-html="<h2>日志功能示意</h2>"><img loading="lazy" src='/xv6/日志功能示意.png' alt="/xv6/日志功能示意.png" height="60%" width="60%"></a><figcaption class="image-caption">日志功能示意</figcaption>
  </figure></p></div><div class="collection-card">
      <div class="collection-title text-secondary">收录于 <a href="/collections/xv6/"><i class="fa-solid fa-layer-group fa-fw" aria-hidden="true"></i> <span>合集・Xv6</span></span></a> 9</div>
      <div class="collection-nav">
        <a href="/posts/mit-lab-mmap/" class="collection-nav-item" rel="prev" title="MIT6.1810 Lab:Mmap"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i><span>MIT6.1810 Lab:Mmap</span>
          </a></div>
    </div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod"><span title="更新于 2025-08-30 10:42:57">更新于 2025-08-30&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"><span><a href="/posts/xv6-note/index.md" title="阅读原始文档" class="link-to-markdown">阅读原始文档</a></span></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="分享到 X" data-sharer="twitter" data-url="http://localhost:1313/posts/xv6-note/" data-title="Xv6读书笔记" data-hashtags="xv6,读书笔记"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://localhost:1313/posts/xv6-note/" data-hashtag="xv6"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://localhost:1313/posts/xv6-note/" data-title="Xv6读书笔记"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="http://localhost:1313/posts/xv6-note/" data-title="Xv6读书笔记"><svg class="icon" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Baidu</title><path d="M9.154.0C7.71.0 6.54 1.658 6.54 3.707c0 2.051 1.171 3.71 2.615 3.71 1.446.0 2.614-1.659 2.614-3.71C11.768 1.658 10.6.0 9.154.0zm7.025.594C14.86.58 13.347 2.589 13.2 3.927c-.187 1.745.25 3.487 2.179 3.735 1.933.25 3.175-1.806 3.422-3.364.252-1.555-.995-3.364-2.362-3.674a1.218 1.218.0 00-.261-.03zM3.582 5.535a2.811 2.811.0 00-.156.008c-2.118.19-2.428 3.24-2.428 3.24-.287 1.41.686 4.425 3.297 3.864 2.617-.561 2.262-3.68 2.183-4.362-.125-1.018-1.292-2.773-2.896-2.75zm16.534 1.753c-2.308.0-2.617 2.119-2.617 3.616.0 1.43.121 3.425 2.988 3.362s2.553-3.238 2.553-3.988c0-.745-.62-2.99-2.924-2.99zm-8.264 2.478c-1.424.014-2.708.925-3.323 1.947-1.118 1.868-2.863 3.05-3.112 3.363-.25.309-3.61 2.116-2.864 5.42.746 3.301 3.365 3.237 3.365 3.237s1.93.19 4.171-.31c2.24-.495 4.17.123 4.17.123s5.233 1.748 6.665-1.616c1.43-3.364-.808-5.109-.808-5.109s-2.99-2.306-4.736-4.798c-1.072-1.665-2.348-2.268-3.528-2.257zm-2.234 3.84 1.542.024v8.197H7.758c-1.47-.291-2.055-1.292-2.13-1.462-.072-.173-.488-.976-.268-2.343.635-2.049 2.447-2.196 2.447-2.196h1.81zm3.964 2.39v3.881c.096.413.612.488.612.488h1.614v-4.343h1.689v5.782h-3.915c-1.517-.39-1.59-1.465-1.59-1.465v-4.317zm-5.458 1.147c-.66.197-.978.708-1.05.928-.076.22-.247.78-.1 1.269.294 1.095 1.248 1.144 1.248 1.144h1.37v-3.34z"/></svg></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/xv6/" class="post-tag" title="标签 - Xv6">Xv6</a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-tag" title="标签 - 读书笔记">读书笔记</a></section>
    <section><span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div><div class="post-nav"><a href="/posts/ostep-note/" class="post-nav-item" rel="prev" title="操作系统导论读书笔记"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>操作系统导论读书笔记</a></div>
</div>
<div class="post-reward">
    <div class="comment"></div>
    <input type="checkbox" class="reward-input" name="reward" id="fi-reward" hidden />
    <label class="reward-button" for="fi-reward"><i class="fa-solid fa-qrcode fa-fw" aria-hidden="true"></i>赞赏</label>
    <div class="reward-ways" data-mode="static"></div>
  </div><div id="comments"><div id="giscus" class="comment">
          <script
            src="https://giscus.app/client.js"
            data-repo="UAreFree/uarefree.github.io"
            data-repo-id="R_kgDONvUezA"
            data-category="Announcements"
            data-category-id="DIC_kwDONvUezM4CvKdr"
            data-mapping="pathname"
            data-strict="0"
            
            data-theme="preferred_color_scheme"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-lang="zh-CN"
            data-loading="lazy"
            crossorigin="anonymous"
            async
            defer
          ></script>
        </div>
        <noscript>
          Please enable JavaScript to view the comments powered by <a href="https://giscus.app/" rel="external nofollow noopener noreferrer">giscus</a>.
        </noscript></div></article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.148.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.4.0-alpha-20250823084643-0f68046a">FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2025</span><span class="author" itemprop="copyrightHolder">
              <a href="https://github.com/UAreFree"target="_blank" rel="external nofollow noopener noreferrer">UAreFree</a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div><div class="fixed-button view-comments d-none" role="button" aria-label="查看评论"><i class="fa-solid fa-comment fa-fw" aria-hidden="true"></i></div></div><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;"></div><noscript>
    <div class="noscript-warning">该网站在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/fuse/fuse.min.js" defer></script><script src="/lib/twemoji/twemoji.min.js" defer></script><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":100},"comment":{"enable":true,"expired":false,"giscus":{"darkTheme":"dark","lightTheme":"light","origin":"https://giscus.app"}},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/search.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":30,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"twemoji":true,"version":"v0.4.0-alpha-20250823084643-0f68046a"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
